{"version":3,"sources":["hash.es6"],"names":[],"mappings":"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","file":"hash.js","sourcesContent":["\n\n\n/**\n * fetch a single value at a normal path (string / int)\n * does not allow wildcard / regex matching keys\n *\n * @param  {Object} object traversable object\n * @param  {String} path path to the value to fetch (safely)\n * @return {Mixed}      value at path or undefined if does not exist\n */\nexport function get(object, path) {\n\n  let tokens = tokenize(path);\n  let token = tokens.shift();\n\n  if (typeof token === 'undefined') { return object; }\n\n  // check owns only; no prototype properties\n  if (!object || !Object.prototype.hasOwnProperty.call(object, token)) {\n    return;\n  }\n\n  return get(object[token], tokens);\n}\n\n/**\n * fetch a single value at a normal path (string / int)\n * does not allow wildcard / regex matching keys\n *\n * @param  {Object} object traversable object\n * @param  {String} path path to the value to fetch (safely)\n * @return {Mixed}      value at path or undefined if does not exist\n */\nexport function insert(object, path, value) {\n\n  // if the path has no wildcard / enum tokens, a simple insert will do\n  if (isSimplePath(path)) {\n    return _simpleInsert(object, path, value);\n  }\n\n  let current = copy(object)\n  let tokens = tokenize(path);\n  let token = tokens.shift();\n  let keys;\n  let destination;\n  let key;\n  let i;\n\n  Object.keys(current)\n    .filter(key => keyMatchesToken(key, token))\n    .forEach((key, i) => {\n      if (tokens.length > 0) {\n        destination = current[key] || (isNumber(key) ? [] : {});\n        current[key] = insert(destination, [].slice.call(tokens), value);\n      } else {\n        current[key] = value;\n      }\n    });\n\n  return current;\n}\n\n\nexport function expand(flat) {\n\n  let current = {};\n\n\n  // out = {}\n  // if (flat.constructor isnt Array)\n  //   flat = [flat]\n  // for set in flat\n  //   for own path, value of set\n  //     tokens = @tokenize(path).reverse()\n  //     value = set[path]\n  //     if tokens[0] is '{n}' or not isNaN Number tokens[0]\n  //       (child = [])[tokens[0]] = value;\n  //     else\n  //       (child = {})[tokens[0]] = value;\n  //     tokens.shift()\n  //     for token in tokens\n  //       if not isNaN Number token\n  //         (parent = [])[parseInt(token, 10)] = child\n  //       else\n  //         (parent = {})[token] = child\n  //       child = parent\n  //     @merge(out, child)\n  // out\n}\n\n/**\n * inserts a value at a path (no exotic matching -- string / int only)\n *\n * @param  {Object} object the object to modify in-place\n * @param  {String} path   the simple path at which to insert the value\n * @param  {Mixed} value  any\n * @return {Mixed}        original object (modified)\n */\nexport function _simpleInsert(object, path, value) {\n\n  let tokens = tokenize(path);\n  let token = tokens.shift();\n  let current = copy(object);\n  let destination;\n\n  if (tokens.length > 0) {\n    destination = current[token] || (isNumber(tokens[0]) ? [] : {});\n    current[token] = _simpleInsert(destination, tokens, value);\n  } else {\n    current[token] = value;\n  }\n\n  return current;\n}\n\nexport function copy(object) {\n  let copied = isArray(object) ? [] : {};\n  Object.keys(object).forEach( (key, i) => { copied[key] = object[key]; });\n  return copied;\n}\n\nexport function _simpleRemove(object, path) {\n  let tokens = tokenize(path);\n  let current = object;\n  let token;\n\n  for (token of tokens) {\n\n  };\n  // hold = data\n  //     if _i is tokens.length - 1\n  //       (removed = {}).item = hold[token]\n  //       if @isArray(hold)\n  //         Array.prototype.splice.call hold, token, 1\n  //       else\n  //         delete hold[token]\n  //       data = removed.item\n  //       return data\n  //     if not hold[token]?\n  //       return data\n  //     hold = hold[token]\n}\n\nexport function tokenize(path = '') {\n\n  if (isArray(path)) return path;\n\n  // 'this.1.example.has.all[4].types'\n  // => ['this', '1', 'example', 'has', 'all', '4]', 'types']\n  return path.split(/\\.|\\[/g).map(token => {\n\n    let parsed\n    let flags;\n\n    if (/\\d+\\]/.test(token)) {\n      // '4]' => 4\n      parsed = parseInt(token.replace(/\\]/, ''), 10);\n      return isNaN(parsed) ? token : parsed;\n\n    } else {\n\n      // normal string\n      return token;\n    }\n  });\n}\n\nfunction keyMatchesToken(key, token) {\n  if (token === key) return true;\n  if (token === '{n}') return !isNaN(parseInt(key, 10));\n  if (token === '{s}') return typeof key === 'string';\n  /* istanbul ignore if */ if (isRegExp(token)) return token.test(key);\n  if (!isNaN(parseInt(token, 10))) {\n    return parseInt(token, 10) === parseInt(key, 10);\n  }\n  return false;\n}\n\nfunction isSimplePath(path = '') {\n  if (isArray(path)) {\n    return !path.some(token => isRegExp(token) || /\\{(n|s)\\}/.test(token));\n  } else {\n    return !/\\{|\\[\\//.test(path);\n  }\n}\n\nfunction isObject(object) {\n  return Object.prototype.toString.call(object) === '[object Object]';\n}\n\nfunction isArray(object) {\n  return Array.isArray(object);\n}\n\nfunction isRegExp(object) {\n  return object.constructor === RegExp;\n}\n\nfunction isEmptyObject(object) {\n  return isObject(object) && Object.keys(object).length < 1;\n}\n\nfunction isNumber(object) {\n  return typeof object === 'number' && object % 1 === 0;\n}"],"sourceRoot":"/source/"}