{"version":3,"sources":["hash.es6"],"names":[],"mappings":"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","file":"hash.js","sourcesContent":["\n\n\n/**\n * fetch a single value at a normal path (string / int)\n * does not allow wildcard / regex matching keys\n *\n * @param  {Object} object traversable object\n * @param  {String} path path to the value to fetch (safely)\n * @return {Mixed}      value at path or undefined if does not exist\n */\nexport function get(object, path) {\n\n  let current = object;\n  let tokens = tokenize(path);\n  let token = tokens.shift();\n\n  // check owns only; no prototype properties\n  if (Object.prototype.hasOwnProperty.call(current, token)) {\n    return tokens.length > 0 ? get(current[token], tokens) : current[token];\n  } else {\n    return;\n  }\n}\n\n/**\n * fetch a single value at a normal path (string / int)\n * does not allow wildcard / regex matching keys\n *\n * @param  {Object} object traversable object\n * @param  {String} path path to the value to fetch (safely)\n * @return {Mixed}      value at path or undefined if does not exist\n */\nexport function insert(object, path, value) {\n\n  // if the path has no wildcard / enum tokens, a simple insert will do\n  if (isSimplePath(path)) {\n    return _simpleInsert(object, path, value);\n  }\n\n  let tokens = tokenize(path);\n  let token = tokens.shift();\n  let keys = Object.keys(object);\n  let destination;\n  let key;\n  let i;\n\n  for ([i, key] of keys.entries()) {\n    if (keyMatchesToken(key, token)) {\n      if (tokens.length > 0) {\n        destination = object[key] || (isNumber(key) ? [] : {});\n        object[key] = insert(destination, [].slice.call(tokens), value);\n      } else {\n        object[key] = value;\n      }\n    }\n  }\n\n  return object;\n}\n\n\nexport function expand(flat) {\n\n  let current = {};\n\n\n  // out = {}\n  // if (flat.constructor isnt Array)\n  //   flat = [flat]\n  // for set in flat\n  //   for own path, value of set\n  //     tokens = @tokenize(path).reverse()\n  //     value = set[path]\n  //     if tokens[0] is '{n}' or not isNaN Number tokens[0]\n  //       (child = [])[tokens[0]] = value;\n  //     else\n  //       (child = {})[tokens[0]] = value;\n  //     tokens.shift()\n  //     for token in tokens\n  //       if not isNaN Number token\n  //         (parent = [])[parseInt(token, 10)] = child\n  //       else\n  //         (parent = {})[token] = child\n  //       child = parent\n  //     @merge(out, child)\n  // out\n}\n\n/**\n * inserts a value at a path (no exotic matching -- string / int only)\n *\n * @param  {Object} object the object to modify in-place\n * @param  {String} path   the simple path at which to insert the value\n * @param  {Mixed} value  any\n * @return {Mixed}        original object (modified)\n */\nexport function _simpleInsert(object, path, value) {\n\n  let tokens = tokenize(path);\n  let lastToken = tokens.pop();\n  let current = object;\n  let token;\n  let i;\n\n  for ([i, token] of tokens.entries()) {\n    if (!current[token]) {\n      current[token] = (isNumber(tokens[i + 1] || lastToken) ? [] : {});\n    }\n    current = current[token];\n  };\n\n  current[lastToken] = value;\n\n  return object;\n}\n\n\nexport function _simpleRemove(object, path) {\n  let tokens = tokenize(path);\n  let current = object;\n  let token;\n\n  for (token of tokens) {\n\n  };\n  // hold = data\n  //     if _i is tokens.length - 1\n  //       (removed = {}).item = hold[token]\n  //       if @isArray(hold)\n  //         Array.prototype.splice.call hold, token, 1\n  //       else\n  //         delete hold[token]\n  //       data = removed.item\n  //       return data\n  //     if not hold[token]?\n  //       return data\n  //     hold = hold[token]\n}\n\nexport function tokenize(path = '') {\n\n  if (isArray(path)) return path;\n\n  // 'this.1.example.has.all[4].types'\n  // => ['this', '1', 'example', 'has', 'all', '4]', 'types']\n  return path.split(/\\.|\\[/g).map(token => {\n\n    let parsed\n    let flags;\n\n    if (/\\d+\\]/.test(token)) {\n      // '4]' => 4\n      parsed = parseInt(token.replace(/\\]/, ''), 10);\n      return isNaN(parsed) ? token : parsed;\n\n    } else {\n\n      // normal string\n      return token;\n    }\n  });\n}\n\nfunction keyMatchesToken(key, token) {\n  if (token === key) return true;\n  if (token === '{n}') return !isNaN(parseInt(key, 10));\n  if (token === '{s}') return typeof key === 'string';\n  /* istanbul ignore if */ if (isRegExp(token)) return token.test(key);\n  if (!isNaN(parseInt(token, 10))) {\n    return parseInt(token, 10) === parseInt(key, 10);\n  }\n  return false;\n}\n\nfunction isSimplePath(path = '') {\n  if (isArray(path)) {\n    return !path.some(token => {\n      return isRegExp(token) || /\\{(n|s)\\}/.test(token);\n    });\n  } else {\n    return !/\\{|\\[\\//.test(path);\n  }\n}\n\nfunction isObject(object) {\n  return Object.prototype.toString.call(object) === '[object Object]';\n}\n\nfunction isArray(object) {\n  return Array.isArray(object);\n}\n\nfunction isRegExp(object) {\n  return object.constructor === RegExp;\n}\n\nfunction isEmptyObject(object) {\n  return isObject(object) && Object.keys(object).length < 1;\n}\n\nfunction isNumber(object) {\n  return typeof object === 'number' && object % 1 === 0;\n}"],"sourceRoot":"/source/"}